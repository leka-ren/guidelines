package main

import "fmt"

// Так как некоторые комментарии длинные, рекомендую перед чтением прожать команду на Windows: Alt+z,а на Mac: option+z

// Создаем структуру в которой будет храниться ссылка на первый элемент в очереди и на последний
type ListNode struct {
	first *ListItem
	// в методе BonusPush опишу как можно использовать поле last
	last *ListItem
}

// Создаем структуру самого элемента в очереди, который будет хранить поле с данными и поле где будет храниться ссылка на след струкруту в очереди
type ListItem struct {
	value int
	next  *ListItem
}

// Метод Push который пытаются дать в практикуме(очень неумело) в качестве примера
func (queue *ListNode) Push(value int) {
	// Инициализируем структуру с данными которую мы хотим добавить
	// Будут храниться данные и next с nil соответственно, чтобы в дальнейшем программа могла понять, что это теперь последний элемент
	item := &ListItem{
		value: value,
		next:  nil,
	}

	// Делаем проверку, есть ли какие то элементы в очереди, не пустая ли она
	if queue.first == nil {
		item := &ListItem{value: value, next: nil}
		// если очередь пустая, добавляемый элемент станет первым
		queue.first = item
		// поле last пока не трогаем, его мы разберем в методе BonusPush дальше
		return
	}

	// но если очередь не пустая, это значит что нам надо пройтись по очереди чтобы добавить в конец наш элемент
	// берем простой цикл for и адаптируем условие выполнения цикла под задачу
	// инициализируем старт: в переменную queueitem присваиваем значение первого элемента в очереди который храниться в ListNode
	// создаем как отдельную переменную чтобы не писать лишние условия внутри for
	queueitem := queue.first

	for {
		// задаем условие когда прервать цикл: пока мы не дойдем до последнего, на последней итерации queue.first.next будет равен nil
		if queueitem.next == nil {
			// когда дошли до последнего, добавляем заранее подготовленный item в queueitem.next
			queueitem.next = item
			// и так как задача функции выполнена, можно делать return
			return
		}

		// на каждой итерации, в переменную queueitem мы перезаписываем значение которое лежит в queueitem.next, чтобы перейти к следующему в очереди
		queueitem = queueitem.next
	}
}

// пример инициализации и чтения
func main() {
	list := ListNode{}
	arr := []int{1, 2, 3, 4, 5, 6, 7}

	// для проверки как работают методы Push и BonusPush нужно вызывать их только по одному, иначе будет паника(проблема с указателями)
	// отправляем по одной цифре из массива
	for _, i := range arr {
		list.Push(i)
		// list.BonusPush(i)
	}

	// читаем каждый элемент в очереди
	for queueitem := list.first; queueitem != nil; queueitem = queueitem.next {
		fmt.Println(queueitem.value)
	}
}

// в этом методе обойдемся без цикла for
func (queue *ListNode) BonusPush(value int) {
	item := &ListItem{
		value: value,
		next:  nil,
	}

	// Точно так же делаем проверку, есть ли какие то элементы в очереди, не пустая ли она
	if queue.first == nil {
		item := &ListItem{value: value, next: nil}
		// если очередь пустая, добавляемый элемент станет первым
		queue.first = item
		// и последним
		queue.last = item
		// ps поле first нужно для того чтобы мы могли пройтись по очереди в случае если нам нужны данные из поля value в *ListItem
		// так же завершаем выполнение функции, так как мы все сделали на первом шаге
		return
	}

	// и дальше, чтобы добавить элемент в очередь, нам по факту нужен только последний элемент из очереди
	// чтобы не использовать цикл для поиска последнего, и поочередно перебирать возможно 10000 или 100000 или 100000000 элементов, что может плохо отразиться на производительности
	// поэтому мы до того как обновить поле last в ListNode, мы должны последнему(еще пока) элементу, выдать ссылку на новый элемент,как в примере с циклом, когда мы делаем "queueitem.next = item", чтобы очередь не теряла связь,
	queue.last.next = item
	// после того как мы обновили ссылку у последнего элемента и связали их с нашим новым элментом, то теперь можно обновить и сам последний элемент, записав туда наш новый ListItem
	queue.last = item
}
